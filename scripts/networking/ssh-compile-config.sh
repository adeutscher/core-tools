#!/bin/bash

# Common message functions.

# Define colours
if [ -t 1 ]; then
  BLUE='\033[1;34m'
  GREEN='\033[1;32m'
  C_FILEPATH='\033[1;32m'
  RED='\033[1;31m'
  YELLOW='\033[1;93m'
  BOLD='\033[1m'
  NC='\033[0m' # No Color
fi

error(){
  printf "$RED"'Error'"$NC"'['"$GREEN"'%s'"$NC"']: %s\n' "$(basename "${0}")" "$@"
}

notice(){
  printf "$BLUE"'Notice'"$NC"'['"$GREEN"'%s'"$NC"']: %s\n' "$(basename "${0}")" "$@"
}

success(){
  printf "$GREEN"'Success'"$NC"'['"$GREEN"'%s'"$NC"']: %s\n' "$(basename "${0}")" "$@"
}

warning(){
  printf "$YELLOW"'Warning'"$NC"'['"$GREEN"'%s'"$NC"']: %s\n' "$(basename "${0}")" "$@"
}

substitute_home(){
  # Need to use sed in order to make use of regex
  # shellcheck disable=SC2001
  sed "s|^${HOME}|~|" <<< "${1}"
}

# Other SSH Commands

get_files(){
  while read -r _possible_file; do
    [ -z "${_possible_file}" ] && continue

    if grep -qi "README" <<< "${_possible_file##*/}"; then
      # Silently skip any file with "README" anywhere in its name.
      continue
    fi

    if grep -qi "\.swp$" <<< "${_possible_file##*/}"; then
      # Silently skip any file ending in a swp extension, likely a vim swap file.
      continue
    fi

    if type file 2> /dev/null >&2 && ! file --mime-type "${_possible_file}" | grep -q "text/plain$"; then
      # If the `file` command is available (this is not the case in MobaXterm),
      #   then silently skip any non-ASCII files (e.g. vim swap files).
      continue
    fi

    echo "${_possible_file}"
  done <<< "$(find "${1}" -type f 2> /dev/null | sort)"
}

get_module_variables_ordered(){

  local moduleVariable
  local priority

  while read -r moduleVariable; do
    [ -z "${moduleVariable}" ] && continue
    # Check for a recorded priority.
    priority="$(grep -Pom1 "priority:\d{1,}" "${!moduleVariable}/ssh/config" 2> /dev/null | cut -d':' -f 2)"
    # Note: Priority will currently not be able to insert a newly-added 5-priority in between a 1-priority and a 10 priority.
    #       It was mostly made as a way to make sure that modules with lots of wildcard configs got placed above other modules.

    printf "%d:%s\n" "${priority:-10}" "${moduleVariable}"

  done <<< "$( (set -o posix; set) | grep -i toolsDir= | cut -d'=' -f1)" | sort -t ':' -k 1n,2 | cut -d':' -f2-

}

print_module_config_to_file(){
  # Print compiled configuration for a module
  # The reason that I am redirecting a block within the function
  #   rather than redirecting the whole module's output is that
  #   I have plans for autogenerated configuration in the near future

  local sshDir
  sshDir="${1}"
  local targetFile
  targetFile="${2}"

  # For '__.d' directories
  local subFile

  {
    # Main config file
    cat "${sshDir}/config"

    # Fluid single-file
    local fluidFile
    fluidFile="${sshDir}/fluid"
    if [ -f "${fluidFile}" ]; then
      printf "\n###\n# Non-versioned subconfig: %s\n\n" "${fluidFile}"
      cat "${fluidFile}"
    fi

    # Print divided configurations
    while read -r subFile; do
      [ -z "${subFile}" ] && continue
      printf "\n###\n# Sub-config \"%s\" for %s\n###\n\n" "${subFile##*/}" "${sshDir}"
      cat "${subFile}";
    done <<< "$(get_files "${sshDir}/config.d")"

    # Fluid.d directory
    while read -r subFile; do
      [ -z "${subFile}" ] && continue
      printf "###\n# Non-versioned sub-config \"%s\" for %s\n###\n\n" "${subFile##*/}" "$sshDir"
      cat "$subFile";
    done <<< "$(get_files "${sshDir}/fluid.d")"

    # Host-specific config
    local hostConfig
    hostConfig="$sshDir/hosts/config-${HOSTNAME%-*}"
    # Be a bit flexible about what hostnames we accept
    # The cause of this was a config for a computer lab with hostnames like 'labpc-01'.
    # I didn't want to write a config for every single one for them.
    if [ -f "${hostConfig}" ]; then
      if [[ "$HOSTNAME" != "${HOSTNAME%-*}" ]]; then
        # Enumerated hostname
        printf "###\n# Host-specific config for %s (generated for %s)\n###\n\n" "${HOSTNAME}" "${HOSTNAME%-*}"
      else
        printf "###\n# Host-specific config for %s\n###\n\n" "${HOSTNAME}"
      fi
      cat "${hostConfig}";
    fi
  } > "${targetFile}"
}

ssh_compile_config(){

  # Set the destination SSH config in a variable.
  # Useful in the event of debugging without stepping on your actual config.
  targetFile="${1:-$HOME/.ssh/config}"
  stagingFile="${targetFile}.temp"

  # If the configuration file exists but cannot be read for for markers,
  #   then assume that it also cannot be written to.
  if [ -f "${targetFile}" ] && [ ! -r "${targetFile}" ]; then
    error "$(printf "Existing config file ${C_FILEPATH}%s${NC} cannot be read for markers. Aborting..." "$(substitute_home "$targetFile")")"
    return 1
  fi

  # Double-check that the parent directory exists
  if ! mkdir -p "$(dirname "${targetFile}")" 2> /dev/null; then
    error "$(printf "Unable to create ${C_FILEPATH}%s${NC} directory." "$(dirname "$targetFile")")"
    return 1
  fi

  # Double-check that we can write to the file and parent directory.
  if [ -f "${targetFile}" ] && [ ! -w "${targetFile}" ] || [ ! -w "$(dirname "${targetFile}")" ]; then
    error "$(printf "Config file ${C_FILEPATH}%s${NC} cannot be written to." "$(substitute_home "${targetFile}")")"
    notice "We will still check all modules for potential updates, though..."
    noWrite=1
  fi

  countModuleTotal=0
  countUpdated=0
  countConfigTotal=0

  backupWritten=0

  while read -r moduleVariable; do
    [ -z "${moduleVariable}" ] && continue
    countModuleTotal=$((countModuleTotal+1))

    # This marker is used by the header for a section
    marker="${moduleVariable}-marker"

    # Recore sshDir as a base for SSH configuration and for use with SSH_DIR token substitution
    sshDir="${!moduleVariable}/ssh"
    # Replace $HOME with ~ for display purposes
    sshDirDisplay="$(substitute_home "${sshDir}/")"

    if [ ! -f "${sshDir}/config" ]; then
      if [ -d "${!moduleVariable}" ]; then
        # No module directory exists, but no SSH configuration file could be found within it.
        # Only making the lack of a configuration in a module give notice (as opposed to a warning or error).
        #   I think that this message is more likely to be a silly FYI than a serious error.
        notice "$(printf "No SSH configuration located at ${GREEN}%s${NC}" "$(substitute_home "${sshDir}/config")")"
      else
        # A module directory vanishing out from under us IS a cause for concern.
        error "$(printf "Module directory not found: ${GREEN}%s${NC}" "$(substitute_home "${!moduleVariable}")")"
      fi
      continue
    fi

    countConfigTotal=$((countConfigTotal+1))

    print_module_config_to_file "${sshDir}" "${stagingFile}"
    # Perform substitutions on staging file.
    sed -i "s|TOOLS_DIR|${!moduleVariable}|g" "${stagingFile}"
    sed -i "s|TOOLS_PARENT|$(readlink -f "${!moduleVariable}/..")|g" "${stagingFile}"
    sed -i "s|SSH_DIR|${sshDir}|g" "${stagingFile}"
    # Get a checksum from our staging file.
    checksum="$(md5sum "${stagingFile}" | cut -d' ' -f1)"

    if [ -f "$targetFile" ]; then
      # SSH Configuration exists, probe for existing versions.
      sectionStart=$(grep -wnm1 "${marker}" "${targetFile}" | cut -d':' -f1)
      sectionEnd=$(grep -wnm1 "${marker}-end" "${targetFile}" | cut -d':' -f1)
      sectionChecksum=$(grep -wm1 "${marker}" "${targetFile}" | grep -o "checksum:[^ ]*" | cut -d':' -f2)
    fi

    # Backup
    if (( ! backupWritten )) && [ -f "${targetFile}" ]; then
      if [ -n "${sectionStart}" ] || [[ "$checksum" != "$sectionChecksum" ]]; then
        # This is our first module with updates to an existing file.
        # Perform a backup of the target file as it was.
        # Putting this block up here because I'd rather duplicate
        #  the if statements for the below update/insert blocks
        #   than duplicate the backing up of a file.
        backupPath="${targetFile}.bak"
        if cp "${targetFile}" "${backupPath}"; then
          notice "$(printf "Backed up ${C_FILEPATH}%s${NC} to ${C_FILEPATH}%s${NC}" "$(substitute_home "${targetFile}")" "$(substitute_home "${backupPath}")")"
        else
          error "$(printf "Failed to back up ${C_FILEPATH}%s${NC} to ${C_FILEPATH}%s${NC}" "$(substitute_home "${targetFile}")" "$(substitute_home "${backupPath}")")"
          exit
        fi
        backupWritten=1
      fi
    fi

    local countUpdated=$((countUpdated+1))

    if [ -z "$sectionEnd" ]; then
      # An end-marker does not exist in our SSH config. Just append it onto the existing config.

      if [ -n "$noWrite" ]; then
        # Could not write to location. Print our warnings now and continue to the next loop.
        if [ -z "$sectionStart" ]; then
          warning "$(printf "SSH config from ${C_FILEPATH}%s${NC} could not be inserted." "${sshDirDisplay}")"
        else
          warning "$(printf "SSH config from ${C_FILEPATH}%s${NC} was corrupted. Data could not be inserted." "${sshDirDisplay}")"
        fi
        continue
      fi

      if [ -n "${sectionStart}" ]; then
        # If this executes (start is set, but end is not), then some joker deleted the end marker.
        # If we cannot determine the proper end, delete everything below then add in.
        sed -i "${sectionStart},${sectionStart}d;q" "$targetFile"

        warning "$(printf "SSH config from ${C_FILEPATH}%s${NC} was corrupted. Someone removed the end marker..." "${sshDirDisplay}")"
        warning "$(printf "Clearing out all content below the ${BOLD}%s{NC} section." "${marker}")"
      fi

      # Write header and general configs.
      {
        printf "# %s checksum:%s\n\n" "${marker}" "${checksum}";
        cat "${stagingFile}" >> "${targetFile}"
        # Write tail.
        printf "\n\n# %s-end\n\n" "${marker}"
      } >> "${targetFile}"

      if [ -z "$sectionStart" ]; then
        success "$(printf "${GREEN}Inserted${NC} SSH config from ${C_FILEPATH}%s${NC}" "${sshDirDisplay}")"
      fi

    elif [[ "$checksum" != "$sectionChecksum" ]]; then
      # This section needs to be separate, as it involves inserting a config block into our existing config instead of just appending.

      if [ -n "$noWrite" ]; then
        warning "$(printf "SSH configuration updates from ${C_FILEPATH}%s${NC} could not be written." "${sshDirDisplay}")"
        continue
      fi

      configLines=$(wc -l < "${targetFile}")

      # Write previous content, header, and general configs.
      {
        head -n "$((sectionStart-1))" "${targetFile}"
        printf "# %s checksum:%s\n\n" "${marker}" "${checksum}"
        cat "${stagingFile}"
        # Write footer and tail
        printf "\n\n# %s-end\n\n" "${marker}"
        tail -n "-$((configLines-sectionEnd-1))" "${targetFile}"
      } > "${targetFile}.new"
      mv "${targetFile}.new" "${targetFile}"

      success "$(printf "${BLUE}Updated${NC} SSH configuration from ${C_FILEPATH}%s${NC}" "${sshDirDisplay}")"

    else
      countUpdated=$((countUpdated-1))
      notice "$(printf "No changes to SSH config from ${C_FILEPATH}%s${NC}" "${sshDirDisplay}")"
    fi
  done <<< "$(get_module_variables_ordered)" # End config loop.

  if [ "${countUpdated}" -ne 1 ]; then
    pluralSection="s"
  fi
  countsPhrasing="$(printf "(${BOLD}%d${NC} SSH section${pluralSection} updated, ${BOLD}%d${NC} sections, ${BOLD}%d${NC} modules)" "${countUpdated}" "${countConfigTotal}" "${countModuleTotal}")"
  if [ "${countUpdated}" -eq 0 ]; then
    notice "$(printf "No updates to ${C_FILEPATH}%s${NC} %s" "$(substitute_home "$targetFile")" "${countsPhrasing}")"
  elif [ -n "${noWrite}" ]; then
    # No-write message
    error "$(printf "Could not update ${C_FILEPATH}%s${NC}, file was not writable... %s" "$(substitute_home <<< "$targetFile")" "${countsPhrasing}")"
  else
    # Standard message.
    notice "$(printf "Updated ${C_FILEPATH}%s${NC} %s" "$(substitute_home "$targetFile")" "${countsPhrasing}")"
  fi

  # Correct permissions
  ssh-fix-permissions

  # Clean up
  rm "${stagingFile}"
}

ssh_compile_config "${1}"
